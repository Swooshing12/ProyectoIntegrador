<?php
namespace App\Controllers;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use App\Utils\ResponseUtil;
use App\Validators\EmailValidator;        // ‚úÖ ESTE
use App\Validators\PasswordValidator;     // ‚úÖ ESTE
use Illuminate\Database\Capsule\Manager as DB;
use Exception;


class AuthController
{
    // PUNTO 1 y 3: Login mejorado con sistema de 3 intentos (SIN CAMPOS NUEVOS)
// PUNTO 1 y 3: Login mejorado con sistema de 3 intentos (SIN CAMPOS NUEVOS)
public function login(Request $request, Response $response): Response
{
    // üî• FORZAR INICIO DE SESI√ìN SIEMPRE - ESTE ES EL CAMBIO CR√çTICO
    if (session_status() == PHP_SESSION_NONE) {
        session_start();
    }
    
    // üî• ASEGURAR QUE LA SESI√ìN TENGA UN ID V√ÅLIDO
    if (empty(session_id())) {
        session_start();
        error_log("üîÑ Session force started: " . session_id());
    } else {
        error_log("üîÑ Session already active: " . session_id());
    }

    $data = $request->getParsedBody();
    
    // Validaciones b√°sicas
    if (empty($data['correo']) || empty($data['password'])) {
        return ResponseUtil::badRequest('Datos incompletos', [
            'correo' => empty($data['correo']) ? 'El correo es requerido' : null,
            'password' => empty($data['password']) ? 'La contrase√±a es requerida' : null
        ]);
    }
    
    // Validar formato de email
    $erroresEmail = EmailValidator::validate($data['correo']);
    if (!empty($erroresEmail)) {
        return ResponseUtil::badRequest('Formato de correo inv√°lido', $erroresEmail);
    }
    
    try {
        // Obtener IP del cliente para logs de seguridad
        $clientIp = $_SERVER['REMOTE_ADDR'] ?? 'unknown';
        
        // üî• LOG DE DEBUG PARA VERIFICAR SESI√ìN
        error_log("üîç Session ID: " . session_id());
        error_log("üîç Current attempts in session: " . json_encode($_SESSION['intentos'] ?? 'NONE'));
        
        // Buscar usuario por correo
        $usuario = DB::table('usuarios')
            ->join('roles', 'usuarios.id_rol', '=', 'roles.id_rol')
            ->leftJoin('doctores', 'usuarios.id_usuario', '=', 'doctores.id_usuario')
            ->leftJoin('especialidades', 'doctores.id_especialidad', '=', 'especialidades.id_especialidad')
            ->leftJoin('pacientes', 'usuarios.id_usuario', '=', 'pacientes.id_usuario')
            ->select(
                'usuarios.id_usuario',
                'usuarios.cedula',
                'usuarios.username',
                'usuarios.nombres',
                'usuarios.apellidos',
                'usuarios.sexo',
                'usuarios.nacionalidad',
                'usuarios.correo',
                'usuarios.password',
                'usuarios.id_estado',
                'usuarios.fecha_creacion',
                'roles.nombre_rol',
                'doctores.id_doctor',
                'especialidades.nombre_especialidad',
                'pacientes.id_paciente'
            )
            ->where('usuarios.correo', $data['correo'])
            ->first();
        
        // üîí MENSAJE SEGURO: No revelar si el usuario existe o no
        if (!$usuario) {
            $this->incrementarIntentosFallidos($data['correo'], $clientIp);
            error_log("Login failed - Email not found: {$data['correo']} from IP: $clientIp");
            return ResponseUtil::unauthorized('Credenciales incorrectas');
        }
        
        // üîí VERIFICAR ESTADO DEL USUARIO
        if ($usuario->id_estado == 2) {
            error_log("Login blocked - Account blocked: {$data['correo']} from IP: $clientIp");
            return ResponseUtil::unauthorized('Cuenta bloqueada por m√∫ltiples intentos fallidos. Contacte al administrador');
        }
        
        if ($usuario->id_estado == 4) {
            error_log("Login blocked - Account disabled: {$data['correo']} from IP: $clientIp");
            return ResponseUtil::unauthorized('Cuenta deshabilitada. Contacte al administrador');
        }
        
        if ($usuario->id_estado != 1 && $usuario->id_estado != 3) {
            error_log("Login blocked - Invalid status {$usuario->id_estado}: {$data['correo']} from IP: $clientIp");
            return ResponseUtil::unauthorized('Estado de cuenta inv√°lido. Contacte al administrador');
        }
        
        // üîí VERIFICAR CONTRASE√ëA
        if (!password_verify($data['password'], $usuario->password)) {
            // Incrementar contador de intentos fallidos
            $intentosActuales = $this->incrementarIntentosFallidos($data['correo'], $clientIp);
            
            // Si lleg√≥ a 3 intentos, bloquear usuario
            if ($intentosActuales >= 3) {
                $this->bloquearUsuario($usuario->id_usuario, $data['correo'], $clientIp);
                return ResponseUtil::unauthorized('Cuenta bloqueada por m√∫ltiples intentos fallidos. Contacte al administrador');
            }
            
            error_log("Login failed - Wrong password: {$data['correo']} (attempt $intentosActuales/3) from IP: $clientIp");
            return ResponseUtil::unauthorized('Credenciales incorrectas');
        }
        
        // Si la contrase√±a es correcta, verificar el estado
        if ($usuario->id_estado == 3) {
            // Usuario con clave temporal - debe cambiar contrase√±a
            return ResponseUtil::success([
                'usuario' => [
                    'id_usuario' => $usuario->id_usuario,
                    'correo' => $usuario->correo,
                    'nombres' => $usuario->nombres,
                    'apellidos' => $usuario->apellidos,
                    'requiere_cambio_password' => true,
                    'estado' => 'pendiente'
                ]
            ], 'Debe cambiar su contrase√±a temporal');
        }

        // üîí LOGIN EXITOSO - Limpiar intentos fallidos
        $this->limpiarIntentosFallidos($data['correo']);
        
        // Preparar datos del usuario
        $tipoUsuario = $usuario->id_doctor ? 'doctor' : ($usuario->id_paciente ? 'paciente' : 'admin');
        
        $userData = [
            'usuario' => [
                'id_usuario' => $usuario->id_usuario,
                'cedula' => $usuario->cedula,
                'username' => $usuario->username,
                'nombres' => $usuario->nombres,
                'apellidos' => $usuario->apellidos,
                'nombre_completo' => $usuario->nombres . ' ' . $usuario->apellidos,
                'sexo' => $usuario->sexo,
                'nacionalidad' => $usuario->nacionalidad,
                'correo' => $usuario->correo,
                'rol' => $usuario->nombre_rol,
                'tipo_usuario' => $tipoUsuario,
                'id_paciente' => $usuario->id_paciente,
                'id_doctor' => $usuario->id_doctor,
                'especialidad' => $usuario->nombre_especialidad,
                'fecha_registro' => $usuario->fecha_creacion
            ]
        ];
        
        // Log de √©xito
        error_log("Login successful: {$data['correo']} ({$usuario->nombre_rol}) from IP: $clientIp");
        
        return ResponseUtil::success($userData, 'Inicio de sesi√≥n exitoso');
        
    } catch (Exception $e) {
        error_log("Login error: " . $e->getMessage());
        return ResponseUtil::error('Error interno del servidor');
    }
}

// üîí INCREMENTAR INTENTOS FALLIDOS (USANDO SESIONES)
// üîí INCREMENTAR INTENTOS FALLIDOS (USANDO SESIONES)
private function incrementarIntentosFallidos($correo, $clientIp)
{
    // üî• ASEGURAR QUE LA SESI√ìN EST√â ACTIVA
    if (session_status() == PHP_SESSION_NONE) {
        session_start();
    }
    
    // üî• LOG DE DEBUG
    error_log("üîç Before increment - Session ID: " . session_id());
    error_log("üîç Before increment - Current session data: " . json_encode($_SESSION));
    
    // Inicializar array de intentos si no existe
    if (!isset($_SESSION['intentos'])) {
        $_SESSION['intentos'] = [];
        error_log("üîÑ Initialized attempts array");
    }
    
    // Incrementar contador para este correo
    if (!isset($_SESSION['intentos'][$correo])) {
        $_SESSION['intentos'][$correo] = 1;
    } else {
        $_SESSION['intentos'][$correo]++;
    }
    
    $intentos = $_SESSION['intentos'][$correo];
    
    // üî• LOG DETALLADO
    error_log("üîç After increment - Attempts for $correo: $intentos");
    error_log("üîç After increment - Full session data: " . json_encode($_SESSION));
    
    error_log("Failed login attempt $intentos/3 for: $correo from IP: $clientIp");
    
    return $intentos;
}
// üîí BLOQUEAR USUARIO (CAMBIAR ESTADO A 2)
private function bloquearUsuario($idUsuario, $correo, $clientIp)
{
    try {
        DB::table('usuarios')
            ->where('id_usuario', $idUsuario)
            ->update(['id_estado' => 2]); // Estado bloqueado
            
        error_log("User blocked after 3 failed attempts: $correo (ID: $idUsuario) from IP: $clientIp");
        
        // Limpiar intentos de la sesi√≥n ya que el usuario est√° bloqueado
        unset($_SESSION['intentos'][$correo]);
        
    } catch (Exception $e) {
        error_log("Error blocking user: " . $e->getMessage());
    }
}

// üîí LIMPIAR INTENTOS FALLIDOS (LOGIN EXITOSO)
private function limpiarIntentosFallidos($correo)
{
    if (isset($_SESSION['intentos'][$correo])) {
        unset($_SESSION['intentos'][$correo]);
    }
}
    
    // NUEVO: Cambiar contrase√±a temporal por nueva (CON VALIDACIONES)
public function changePassword(Request $request, Response $response): Response
{
    $data = $request->getParsedBody();
    
    // Validaciones b√°sicas
    $requiredFields = ['correo', 'password_actual', 'password_nueva', 'confirmar_password'];
    foreach ($requiredFields as $field) {
        if (empty($data[$field])) {
            return ResponseUtil::badRequest("El campo {$field} es requerido");
        }
    }
    
    // Validar que las contrase√±as coincidan
    if ($data['password_nueva'] !== $data['confirmar_password']) {
        return ResponseUtil::badRequest('Las contrase√±as no coinciden');
    }
    
    // üî• VALIDAR NUEVA CONTRASE√ëA CON EL VALIDATOR
    $passwordErrors = PasswordValidator::validate($data['password_nueva']);
    if (!empty($passwordErrors)) {
        return ResponseUtil::badRequest('Contrase√±a no v√°lida', $passwordErrors);
    }
    
    try {
        // Buscar usuario
        $usuario = DB::table('usuarios')
            ->select('id_usuario', 'correo', 'password', 'id_estado', 'nombres', 'apellidos')
            ->where('correo', $data['correo'])
            ->first();
        
        if (!$usuario) {
            return ResponseUtil::unauthorized('Usuario no encontrado');
        }
        
        // Verificar que est√© en estado pendiente (3)
        if ($usuario->id_estado != 3) {
            return ResponseUtil::badRequest('El usuario no est√° en proceso de cambio de contrase√±a');
        }
        
        // Verificar contrase√±a temporal actual
        if (!password_verify($data['password_actual'], $usuario->password)) {
            return ResponseUtil::unauthorized('La contrase√±a temporal es incorrecta');
        }
        
        // Verificar que la nueva no sea igual a la temporal
        if (password_verify($data['password_nueva'], $usuario->password)) {
            return ResponseUtil::badRequest('La nueva contrase√±a debe ser diferente a la temporal');
        }
        
        // üî• ENCRIPTAR NUEVA CONTRASE√ëA
        $nuevaPasswordEncriptada = password_hash($data['password_nueva'], PASSWORD_DEFAULT);
        
        // ‚úÖ ACTUALIZAR CONTRASE√ëA Y CAMBIAR ESTADO A ACTIVO (1)
        DB::table('usuarios')
            ->where('id_usuario', $usuario->id_usuario)
            ->update([
                'password' => $nuevaPasswordEncriptada,
                'id_estado' => 1  // üîÑ ESTADO ACTIVO
            ]);
        
        // Log de seguridad
        error_log("Password changed successfully: {$data['correo']} - User ID: {$usuario->id_usuario}");
        
        return ResponseUtil::success([
            'password_changed' => true,
            'usuario_activado' => true,
            'mensaje_usuario' => 'Contrase√±a cambiada exitosamente. Ya puede iniciar sesi√≥n con su nueva contrase√±a.'
        ], 'Contrase√±a actualizada correctamente');
        
    } catch (Exception $e) {
        error_log("Password change error: " . $e->getMessage());
        return ResponseUtil::error('Error cambiando la contrase√±a. Intente nuevamente');
    }
}


    
    // MEJORADO: Enviar clave temporal por email CON CAMBIO DE ESTADO
public function enviarClaveTemporalEmail(Request $request, Response $response): Response
{
    $data = $request->getParsedBody();
    
    // Validar email
    if (empty($data['correo'])) {
        return ResponseUtil::badRequest('El correo es requerido');
    }
    
    // Validar formato de email
    $erroresEmail = EmailValidator::validate($data['correo']);
    if (!empty($erroresEmail)) {
        return ResponseUtil::badRequest('Email inv√°lido', $erroresEmail);
    }
    
    try {
        // Verificar que el usuario existe
        $usuario = DB::table('usuarios')
            ->select('id_usuario', 'correo', 'nombres', 'apellidos', 'id_estado')
            ->where('correo', $data['correo'])
            ->first();
        
        if (!$usuario) {
            // üîí MENSAJE SEGURO - No revelar si existe o no
            return ResponseUtil::success([
                'clave_temporal_generada' => true,
                'correo_enviado' => true,
                'mensaje_usuario' => 'Si el correo existe en nuestro sistema, recibir√°s una clave temporal.'
            ], 'Solicitud procesada exitosamente');
        }
        
        // Verificar que no est√© bloqueado
        if ($usuario->id_estado == 2) {
            return ResponseUtil::badRequest('Cuenta bloqueada. Contacte al administrador');
        }
        
        if ($usuario->id_estado == 4) {
            return ResponseUtil::badRequest('Cuenta deshabilitada. Contacte al administrador');
        }
        
        // Generar clave temporal ESPEC√çFICA para recuperaci√≥n
        require_once __DIR__ . '/../../../config/MailService.php';
        $claveTemporalRecuperacion = \MailService::generarClaveRecuperacion();
        
        // üî• ENCRIPTAR CON BCRYPT
        $passwordEncriptada = password_hash($claveTemporalRecuperacion, PASSWORD_DEFAULT);
        
        // ‚úÖ ACTUALIZAR CONTRASE√ëA Y CAMBIAR ESTADO A 3 (PENDIENTE)
        DB::table('usuarios')
            ->where('id_usuario', $usuario->id_usuario)
            ->update([
                'password' => $passwordEncriptada,
                'id_estado' => 3  // üîÑ ESTADO PENDIENTE
            ]);
        
        // Enviar por email
        $mailService = new \MailService();
        $nombreCompleto = $usuario->nombres . ' ' . $usuario->apellidos;
        
        $emailEnviado = $mailService->enviarClaveRecuperacion(
            $data['correo'],
            $nombreCompleto,
            $claveTemporalRecuperacion
        );
        
        if ($emailEnviado) {
            // Log de seguridad
            error_log("Password recovery sent: {$data['correo']} - User ID: {$usuario->id_usuario}");
            
            return ResponseUtil::success([
                'clave_temporal_generada' => true,
                'correo_enviado' => true,
                'mensaje_usuario' => 'Te hemos enviado una clave temporal a tu correo electr√≥nico. √ösala para cambiar tu contrase√±a.'
            ], 'Clave temporal de recuperaci√≥n enviada exitosamente');
        } else {
            return ResponseUtil::error('Error enviando el correo. Intenta nuevamente');
        }
        
    } catch (Exception $e) {
        error_log("Password recovery error: " . $e->getMessage());
        return ResponseUtil::error('Error procesando la solicitud. Intenta nuevamente');
    }

    
    
}

// NUEVO: Cambiar contrase√±a para usuario logueado (NO temporal)
public function changePasswordLoggedUser(Request $request, Response $response): Response
{
    $data = $request->getParsedBody();
    
    // Validaciones b√°sicas
    $requiredFields = ['id_usuario', 'password_actual', 'password_nueva', 'confirmar_password'];
    foreach ($requiredFields as $field) {
        if (empty($data[$field])) {
            return ResponseUtil::badRequest("El campo {$field} es requerido");
        }
    }
    
    // Validar que las contrase√±as coincidan
    if ($data['password_nueva'] !== $data['confirmar_password']) {
        return ResponseUtil::badRequest('Las contrase√±as no coinciden');
    }
    
    // Validar que la nueva contrase√±a sea diferente a la actual
    if ($data['password_actual'] === $data['password_nueva']) {
        return ResponseUtil::badRequest('La nueva contrase√±a debe ser diferente a la actual');
    }
    
    // üî• VALIDAR NUEVA CONTRASE√ëA CON EL VALIDATOR
    $passwordErrors = PasswordValidator::validate($data['password_nueva']);
    if (!empty($passwordErrors)) {
        return ResponseUtil::badRequest('La nueva contrase√±a no cumple los requisitos de seguridad', $passwordErrors);
    }
    
    try {
        // Buscar usuario por ID
        $usuario = DB::table('usuarios')
            ->select('id_usuario', 'cedula', 'correo', 'password', 'id_estado', 'nombres', 'apellidos')
            ->where('id_usuario', $data['id_usuario'])
            ->first();
        
        if (!$usuario) {
            return ResponseUtil::notFound('Usuario no encontrado');
        }
        
        // Verificar que el usuario est√© activo
        if ($usuario->id_estado != 1) {
            return ResponseUtil::badRequest('El usuario no est√° activo. Contacte al administrador');
        }
        
        // Verificar contrase√±a actual
        if (!password_verify($data['password_actual'], $usuario->password)) {
            return ResponseUtil::unauthorized('La contrase√±a actual es incorrecta');
        }
        
        // üî• ENCRIPTAR NUEVA CONTRASE√ëA
        $nuevaPasswordEncriptada = password_hash($data['password_nueva'], PASSWORD_DEFAULT);
        
        // ‚úÖ ACTUALIZAR CONTRASE√ëA (mantener estado activo)
        DB::table('usuarios')
            ->where('id_usuario', $usuario->id_usuario)
            ->update([
                'password' => $nuevaPasswordEncriptada
            ]);
        
        // Log de seguridad
        error_log("Password changed by logged user: {$usuario->correo} (ID: {$usuario->id_usuario})");
        
        return ResponseUtil::success([
            'password_changed' => true,
            'usuario' => [
                'id_usuario' => $usuario->id_usuario,
                'correo' => $usuario->correo,
                'nombres' => $usuario->nombres,
                'apellidos' => $usuario->apellidos
            ]
        ], 'Contrase√±a actualizada exitosamente');
        
    } catch (Exception $e) {
        error_log("Password change error for logged user: " . $e->getMessage());
        return ResponseUtil::error('Error cambiando la contrase√±a. Intente nuevamente');
    }
}


}
?>